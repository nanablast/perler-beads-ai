# 一键去背景功能文档

## 功能概述

"一键去背景"是拼豆图纸生成器中的一个智能功能，用于自动识别并去除图片边缘的背景色。该功能通过分析像素网格的边缘颜色分布，找出最可能的背景色，然后使用洪水填充算法将其替换为透明区域。

---

## 核心逻辑流程

### 1. 入口与触发

**文件位置**: [src/app/page.tsx](file:///d:/perler-beads-master/src/app/page.tsx#L1268-L1338)

```typescript
const handleAutoRemoveBackground = () => {
  // 前置检查：确保已生成图纸
  if (!mappedPixelData || !gridDimensions) {
    alert('请先生成图纸后再使用一键去背景。');
    return;
  }
  // ... 核心逻辑
}
```

**UI按钮位置**: [src/app/page.tsx](file:///d:/perler-beads-master/src/app/page.tsx#L2271)

```tsx
<button
  onClick={handleAutoRemoveBackground}
  disabled={!mappedPixelData || !gridDimensions}
  className="..."
>
  一键去背景
</button>
```

---

### 2. 背景色识别算法

#### 2.1 边缘像素统计

功能首先统计网格四周边缘的所有像素颜色出现频率：

```typescript
const borderCounts = new Map<string, number>();

// 统计上边缘和下边缘
for (let col = 0; col < N; col++) {
  countBorderCell(0, col);           // 上边缘
  if (M > 1) countBorderCell(M - 1, col);  // 下边缘
}

// 统计左边缘和右边缘（排除已统计的角落）
for (let row = 1; row < M - 1; row++) {
  countBorderCell(row, 0);           // 左边缘
  if (N > 1) countBorderCell(row, N - 1);  // 右边缘
}
```

#### 2.2 找出主背景色

从边缘统计中找出出现次数最多的颜色作为目标背景色：

```typescript
let targetKey = '';
let maxCount = -1;
borderCounts.forEach((count, key) => {
  if (count > maxCount) {
    maxCount = count;
    targetKey = key;
  }
});
```

**边界情况处理**:
- 如果边缘没有可识别的颜色 → 提示"边缘没有可识别的背景颜色"
- 如果找不到可去除的背景区域 → 提示"未找到可去除的背景区域"

---

### 3. 洪水填充去除背景

#### 3.1 算法核心

使用**栈实现的非递归洪水填充算法**（Flood Fill），从边缘开始向内部扩散：

```typescript
// 初始化访问标记数组
const visited = Array(M).fill(null).map(() => Array(N).fill(false));
const stack: { row: number; col: number }[] = [];

// 从四周边缘开始，将所有目标颜色的像素加入栈
for (let col = 0; col < N; col++) {
  pushIfTarget(0, col);              // 上边缘
  if (M > 1) pushIfTarget(M - 1, col);  // 下边缘
}
for (let row = 1; row < M - 1; row++) {
  pushIfTarget(row, 0);              // 左边缘
  if (N > 1) pushIfTarget(row, N - 1);  // 右边缘
}
```

#### 3.2 填充过程

```typescript
while (stack.length > 0) {
  const { row, col } = stack.pop()!;
  
  // 将当前像素设为透明
  newPixelData[row][col] = { ...transparentColorData };
  
  // 将相邻像素加入栈（上、下、左、右）
  pushIfTarget(row - 1, col);
  pushIfTarget(row + 1, col);
  pushIfTarget(row, col - 1);
  pushIfTarget(row, col + 1);
}
```

#### 3.3 透明色定义

**文件位置**: [src/utils/pixelEditingUtils.ts](file:///d:/perler-beads-master/src/utils/pixelEditingUtils.ts#L4-L9)

```typescript
export const TRANSPARENT_KEY = 'ERASE';

export const transparentColorData: MappedPixel = { 
  key: TRANSPARENT_KEY, 
  color: '#FFFFFF', 
  isExternal: true  // 标记为外部/透明区域
};
```

---

### 4. 状态更新

去除背景后，需要重新计算颜色统计信息：

```typescript
// 更新像素数据
setMappedPixelData(newPixelData);

// 重新计算颜色统计（排除透明像素）
const newColorCounts: { [hexKey: string]: { count: number; color: string } } = {};
let newTotalCount = 0;

newPixelData.flat().forEach(cell => {
  if (cell && !cell.isExternal && cell.key !== TRANSPARENT_KEY) {
    const cellHex = cell.color.toUpperCase();
    if (!newColorCounts[cellHex]) {
      newColorCounts[cellHex] = { count: 0, color: cellHex };
    }
    newColorCounts[cellHex].count++;
    newTotalCount++;
  }
});

setColorCounts(newColorCounts);
setTotalBeadCount(newTotalCount);
setInitialGridColorKeys(new Set(Object.keys(newColorCounts)));
```

---

## 相关工具函数

### 洪水填充工具

**文件位置**: [src/utils/floodFillUtils.ts](file:///d:/perler-beads-master/src/utils/floodFillUtils.ts)

| 函数 | 功能 |
|------|------|
| `getConnectedRegion` | 获取从指定点开始的目标颜色连通区域 |
| `getAllConnectedRegions` | 获取所有同颜色的连通区域 |
| `isRegionCompleted` | 检查区域是否完全已完成 |
| `isRegionPartiallyCompleted` | 检查区域是否部分已完成 |
| `getRegionCenter` | 获取区域的中心点 |
| `sortRegionsByDistance` | 按距离排序区域 |
| `sortRegionsBySize` | 按大小排序区域 |

### 像素编辑工具

**文件位置**: [src/utils/pixelEditingUtils.ts](file:///d:/perler-beads-master/src/utils/pixelEditingUtils.ts)

| 函数 | 功能 |
|------|------|
| `floodFillErase` | 洪水填充擦除算法（通用版本） |
| `replaceColor` | 全局颜色替换 |
| `paintSinglePixel` | 单个像素上色 |
| `recalculateColorStats` | 重新计算颜色统计 |

---

## 算法特点

### 优点
1. **智能识别**: 自动分析边缘颜色，无需用户手动选择背景色
2. **连通区域处理**: 只去除与边缘相连的背景区域，保留内部的同色图案
3. **非递归实现**: 使用栈代替递归，避免大数据量时的栈溢出问题
4. **四向连通**: 只考虑上下左右四个方向，避免斜向误填充

### 局限性
1. **依赖边缘颜色**: 如果背景色在边缘出现较少，可能无法正确识别
2. **单一背景色**: 每次只能去除一种主要背景色
3. **连通性要求**: 如果背景被图案分割成不连通区域，可能需要多次操作

---

## 使用场景

1. **纯色背景图片**: 白色、黑色或其他纯色背景的照片
2. **简单背景**: 颜色较为单一的背景
3. **预处理**: 在AI优化前去除明显背景，提高处理效果

---

## 与其他功能的关系

| 功能 | 关系 |
|------|------|
| **AI优化** | 可在去背景后使用，获得更好的像素化效果 |
| **手动擦除模式** | 去背景是自动版，手动擦除可处理剩余细节 |
| **颜色排除** | 去背景后可通过颜色排除进一步精简 |
| **颜色替换** | 可将去除的背景区域替换为其他颜色 |

---

## 代码调用链

```
用户点击"一键去背景"按钮
    ↓
handleAutoRemoveBackground() [page.tsx]
    ↓
1. 检查 mappedPixelData 和 gridDimensions
2. 统计边缘颜色 → borderCounts
3. 找出主背景色 → targetKey
4. 创建像素数据副本
5. 洪水填充算法
    ↓
更新状态: setMappedPixelData, setColorCounts, setTotalBeadCount
    ↓
UI自动重新渲染，显示去除背景后的效果
```

---

## 注意事项

1. **操作不可逆**: 去背景操作会直接修改像素数据，建议在操作前保存或导出当前进度
2. **多次操作**: 如果图片有多种背景色，可能需要多次点击"一键去背景"
3. **边缘检测**: 确保图片主体不接触边缘，否则可能被误识别为背景
4. **性能考虑**: 大图片（>200x200像素）可能需要较长的处理时间
